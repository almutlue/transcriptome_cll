---
title: "WGCNA_ddsRNA2017-08-16"
author: "Almut Luetge"
date: "August 15, 2017"
output: html_document
---


#Aim find modules of correlated gene expression:
WGCNA is an alternative method to find feature related gene sets based on correlated gene expression. the approach calculates Eigengenes as representatives of each moules. In contrast to Deseq it works with correlated gene expression instead of differential expression. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages, message = FALSE, warning = FALSE}

options(stringsAsFactors = FALSE)
library(WGCNA)
library(ggplot2)
library(genefilter)
library(randomForest)
library(ROCR)
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(DESeq2)
library(geneplotter)
library(limma)
library(biomaRt)
library(reshape2)
library(beeswarm)
library(Rtsne)
library(stats)
library(base)

```


##Data
```{r load data}

#RNA dataset
load("/home/almut/Documents/CLL/data/2017-08-16_ddsrna_trimmed.RData")

#Clinical trait data
load("/home/almut/Documents/CLL/data/patmetaGroups_170324.RData")


```


##Integrate interesting feature to data set

```{r Add metadata}

patMat <- patMeta[which(patMeta$Patient.ID %in% colData(dds)$PatID),]
genomDat <- apply(patMat[,c(12:98)], 2, function(x) as.numeric(as.character(x)))
intGenom <- genomDat[, which(colSums(genomDat, na.rm=T) > 10)]
patMat <-patMat[, c("Patient.ID","Methylation_Cluster", colnames(intGenom), "c1c2", "drugGroup")]
patMat <- lapply(patMat, function(x) as.factor(x))
patMat <- as.data.frame(patMat)
rownames(patMat) <- patMat$Patient.ID
patMat <- patMat[,-1]
patMat <- patMat[colData(dds)$PatID,]
colData(dds) <- cbind(colData(dds), patMat)


```



Normalization and Data preparation
```{r data preprocessing}
#remove Y-chromosome
dds <- dds[!rowData(dds)$chromosome %in% c("Y"),]

#subset with CLL patients only
cll_vector <- c("CLL", "atyp CLL", "Atyp. CLL","CLL/ET")
ddsCLL <- dds[,colData(dds)$diag %in% cll_vector]

#only keep genes with a gene symbol annotation (reasonable?)
rnaCLL <-ddsCLL[!is.na(rowData(ddsCLL)$symbol),]
rnaCLL <- rnaCLL[rowData(rnaCLL)$symbol != "",]

dim(rnaCLL)

#only keep protein coding genes
rnaCLL <-ddsCLL[!is.na(rowData(ddsCLL)$biotype),]
rnaCLL <- rnaCLL[rowData(rnaCLL)$biotype == "protein_coding",]


#number genes and samples
dim(dds)
dim(ddsCLL)
dim(rnaCLL)
ngenes <-nrow(rnaCLL)
nsamples <-ncol(rnaCLL)

# Remove rows/genes with too few counts
keep <-apply(counts(rnaCLL), 1, function(x) any(x >= 10))
rnaCLL <- rnaCLL[keep,]

#Variance stabilization transformation of the raw data
rnaCLL <- estimateSizeFactors(rnaCLL)
RNAnorm <- varianceStabilizingTransformation(rnaCLL, blind=T)

```



## Gene coexpression network analysis

```{r network construction, fig.height = 15, fig.width = 25}

exprMat <- assay(RNAnorm)

#top5000 most variant genes
sds <- rowSds(exprMat)
exprCLL <- t(exprMat[order(sds, decreasing = T)[1:15000],])

rownames(exprCLL) <- paste0(colData(RNAnorm)$PatID, "_", colData(RNAnorm)$c1c2)


#check for outlier
sampleTree <- hclust(dist(exprCLL), method = "ward.D2")
plot(sampleTree, main = "Sample Clustering to detect outliers", sub =", xlab=", cex.lab = 1.5, cex.main = 2)

#Network construction
par(mfrow = c(1,2))
powers = c(c(1:10), seq(from =12, to = 20, by = 2))
sft <- pickSoftThreshold(exprCLL, powerVector = powers, verbose = 5, networkType = "signed", corFnc = "bicor", corOptions = "maxPOutliers = 0.1")
#sft <- pickSoftThreshold(exprCLL, powerVector = powers, verbose = 5, networkType = "signed", corFnc = "cor") #using Pearson

#Scale independence
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3]) * sft$fitIndices[,2], xlab = "Soft Threshold (power)", ylab = "Scale free topology model fit, signed RÂ²", main = "Scale independence", type = "n")
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3]) * sft$fitIndices[,2], labels = powers, col = "red")
abline(h = 0.90, col = "red")

#Mean connectivity
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab = "Soft Threshold (power)", ylab = "Mean connectivity", type = "n", main = "Mean connectivity")
text(sft$fitIndices[,1], sft$fitIndices[,5], labels = powers, col = "red")





```


Topological Overlap Matrix
```{r Adjajency matrix}
#Choose a reasonable size of soft power from the plots

softPower <- 9  #change!!

#adjacency matrix using bicor/pearson
adjacency <- adjacency(exprCLL, power = softPower, type = "signed", corFnc = "bicor", corOptions = "maxPOutliers = 0.1")
#adjacency <- adjacency(exprCLL, power = softPower, type = "signed", corFnc = "cor")

#Topological overlap matrix
TOM = TOMsimilarity(adjacency, TOMType = "signed")
dissTOM = 1-TOM

save(list = c("dissTOM", "adjacency"), file = "/home/almut/Documents/CLL/network/2017-08-16-RNAseq_data/dissTom_proteinCoding.RData", compress = T)






```

##Module detection

```{r modules, fig.height = 15, fig.width = 20}
##load saved TOM (calculating adjacency matrix and TOM are time consuming)
#load(file = "/home/almut/Documents/CLL/network/2017-08-16-RNAseq_data/dissTom.RData")

#Clustering using using TOM
geneTree <- hclust(as.dist(dissTOM), method = "average")
plot(geneTree, xlab = "", sub = "", main = "Gene clusteribng on TOM based dissilimarities", labels = F, hang = 0.04)

##Detect module
#Interested in large modules, so set minimum module size relative high
minModuleSize = 30
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM, deepSplit = 2, pamRespectsDendro = F, minClusterSize = minModuleSize)
table(dynamicMods)

#Convert numeric lables into colors   
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

#plot the dendogramm with colors underneath
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels = F, hang = 0.03, addGuide = T, guideHang = 0.05, main = "Gene dendogramm and module colors")





```


Merge modules
```{r merge modules, fig.height = 15, fig.width = 20}
##merge modules with really similar expression profiles

#Calculate eigengenes
MEList <- moduleEigengenes(exprCLL, colors=dynamicColors)
MEs <- MEList$eigengenes
rownames(MEs) <- rownames(exprCLL)

#Disimilarities of module eigengenes
MEDiss <- 1 - cor(MEs)

#Eigengene correlations
MEsim <- cor(MEs)
pheatmap(MEsim)

#Cluster module eigengenes
METree <-  hclust(as.dist(MEDiss), method = "average")
plot(METree, main = "Clustering of module eigengenes", xlab ="", sub ="")

#Define threshold <- 0.2 corresponds to a correlation of 0.8  ### Try different to see how robust modules are
MEDissThres <- 0.2
#plot cutline into dendogramm
abline(h = MEDissThres, col = "red")


#Call an automatic merging function
merge <- mergeCloseModules(exprCLL, dynamicColors, cutHeight= MEDissThres, verbose = 3)

#merged module colors (refers colors to genes)
mergedColors <- merge$colors

#Eigengenes of the new merged modules:
mergedMEs = merge$newMEs

#plot the new merged modules
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels = F, hang = 0.03, addGuide = T, guideHang = 0.05)




```


Calculate the modules Eigengenes
```{r Eigengenes}
#Rename to module colors
moduleColors = mergedColors

#construct numerical labels to colors (numeric reference to the module for all genes)
colorOrder = c("grey", standardColors(50))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs
rownames(MEs) <- rownames(exprCLL)
table(mergedColors)

#Disimilarities of module eigengenes
MEDissNew <- 1 - cor(MEs)


#new module correlations
MESimNew <- cor(MEs)
pheatmap(MESimNew)

#expression of the modules Eigengene for every patient 
eigenGene <- MEs 
rownames(eigenGene) <- rownames(exprCLL)

#Gene to module reference
geneColor <- mergedColors
names(geneColor) <- colnames(exprCLL)


save(list = c("eigenGene", "geneColor"), file = "/home/almut/Documents/CLL/network/2017-08-16-RNAseq_data/eigenGene.RData")


```



##Visualizing gene modules using MDS plot
```{r mds plot, eval=FALSE, include=FALSE}

cmd1=cmdscale(as.dist(dissTOM),2)
par(mfrow=c(1,1))
plot(cmd1, col=as.character(mergedColors),  main="MDS plot",xlab="Scaling Dimension 1",ylab="Scaling Dimension 2", cex.axis=1.5,cex.lab=1.5, cex.main=1.5) 





```


##Visualizing the genes and module using t-sne

```{r tsne}

#Calculate t-sne (t-distributed Stochastic Neighbor Embedding)
distGene <- dist(t(exprCLL[,c(1:1000)]))
tsneRes <- Rtsne(distGene, perplexity = 50, theta = 0, max_iter = 5000, is_distance = T, dims =2)
tsneRes <-tsneRes$Y
rownames(tsneRes) <- labels(distGene)
colnames(tsneRes) <- c("x", "y")
tsneRes <- data.frame(tsneRes)
tsneRes$module <-geneColor[rownames(tsneRes)]

#plot using ggplot2
ggplot(tsneRes, aes(x = x, y = y, color = module)) + geom_point(size = 1) + theme_classic() + theme(panel.border = element_rect(color = 'black', size = 1, linetype = 'solid', fill = NA), axis.ticks = element_line(color = "black", size = 1), text = element_text(size = 20)) + xlab("") + ylab("")


```


Correlate genetic background with eigengenes
```{r hypothesis tests}
#Correlate genetic background with eigengenes
#get genetic background data set from patients
netGen <- patMeta %>% dplyr::filter(Patient.ID %in% colData(RNAnorm)$PatID) %>% dplyr::select(Patient.ID, gain2p25.3:ZC3H18)
netGen <- as.data.frame(netGen)
rownames(netGen) <- netGen$Patient.ID
netGene <- as.matrix(netGen[,-1])
class(netGene) <- "numeric"

#select variants with at least 10 samples with information on the variation (0 or 1) and 3 with the variant (1)
sele <- apply(netGene, 2, function(x) sum(!is.na(x)) >= 10 & sum(x %in% 1) >= 3)   
netGene <- netGene[,sele]

##### Bring netGene and MEs in same row order
MEs <- MEs[rownames(netGene),]


#Performed hypothesis test for each eigengene-variants variation
#matrix to store p-values
p.raw.mat <- matrix(NA, ncol(MEs), ncol(netGene))
colnames(p.raw.mat) <- colnames(netGene)
rownames(p.raw.mat) <- colnames(MEs)

for (i in 1:ncol(MEs)) {
  for (j in 1:ncol(netGene)) {
    valueME <-MEs[,i]
    genotype <-netGene[,j]
    p.raw.mat[i,j] <- t.test(valueME~genotype, var.equal = T, na.action = "na.omit")$p.value
  }
}

plist <- melt(p.raw.mat)
plist <- plist[order(plist$value),]
colnames(plist) <- c("Eigengene","Variant", "p.raw")
plist$p.adj <- p.adjust(plist$p.raw, method = "BH")

plist.sig <- plist[plist$p.raw <= 0.05,]
plist.adj <- plist[plist$p.adj <= 0.05,]


```


#Significant gene variant - module relationships
Beeswarm Plots

```{r significant gene variant - module plots}

#function for beeswarm plot of each gene variant

plotBeesTab <- function(tabPlot) {
  for (i in 1:nrow(tabPlot)) {
    mutName <- tabPlot[i,2]  #name of variant stored in second column
    eigName <- tabPlot[i,1]  #name of eigengene stored in the 1. column
    dataComp <- data.frame(Eigengene = MEs[,eigName], Variant = netGene[,mutName])
    boxplot(Eigengene~Variant, data = dataComp, outline =F, main = mutName, ylab ="measurement", pars = list(boxwex=0.5, staplewex = 0.5, boxlwd = 0.3, medlwd = 0.5, staplelwd = 0.5), xlab = sprintf("adjusted P = %.3f", tabPlot[i,4]))
    beeswarm(Eigengene ~ Variant, data= dataComp, add = T, pch= 16, cex = 0.5, col = c("red", "black", "blue"))
    title(measure, outer= T)
  }
}


#pdf(paste("/home/almut/Documents/CLL/network/2017-04-05-RNAseq_data/EigenGene_VS_Variant.pdf", height = 8, width = 8)

for (measure in unique(plist.sig$Eigengene)) {
  par(mfrow=c(2,2), oma = c(0,0,1.5,0))
  plotTab <- plist.sig[plist.sig$Eigengene == measure,]
  plotBeesTab(plotTab)
  
}

#dev.off()

#pList <- sapply(unique(plist.sig$Eigengene), function(measure){
#  plotTab <- plist.sig[plist.sig$Eigengene == measure,]
#  plotBeesTab(plotTab)
#})


#grid.arrange(grobs = pList, ncol = 4)

```


##Analysis of significant module/gene variant relationships

#Gene significance GS and Module membership MM

Correlation between genes and traits/genetic variants
```{r Module Membership}
# Define numbers of genes and samples
nGenes <- ncol(exprCLL);
nSamples <- nrow(exprCLL)

#names (colors) of the modules
modNames <- substring(names(MEs), 3)

#Calculate gene module membership
geneModuleMembership = as.data.frame(cor(exprCLL, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

```


```{r gene significance}

#Calculate Gene-Trait/variant significance

#function for correlation of each gene with the gene variants 

#matrix to store p-values
GSTrait <- matrix(NA, ncol(exprCLL), ncol(netGene))
colnames(GSTrait) <- colnames(netGene)
rownames(GSTrait) <- colnames(exprCLL)

pGS <- matrix(NA, ncol(exprCLL), ncol(netGene))
colnames(pGS) <- colnames(netGene)
rownames(pGS) <- colnames(exprCLL)



for (j in 1:ncol(netGene)) {
    genotype <-netGene[,j]
    geneTraitSignificance <- cor(exprCLL, genotype, use = "p")
    GSPvalue = corPvalueStudent(as.matrix(geneTraitSignificance), nSamples)
    pGS[,j] <- GSPvalue
    GSTrait[,j] <- geneTraitSignificance
}



```



#Intramodular analysis
Genes with high GS and high MM

```{r Intramodular analysis}

plist.adj <- as_data_frame(plist.adj)

for (module in unique(plist.adj$Eigengene)){
  modModule <- substring(module, 3)
  column <- match(modModule, modNames)
  moduleGenes <- names(geneColor)[which(geneColor== modModule)]
  variantvector <-plist.adj %>% dplyr::mutate_at(vars(starts_with("ME")),funs(character)) %>% dplyr::filter(Eigengene %in% module) %>% dplyr::select(Variant)
  variantvector <-as.data.frame(variantvector)
  for (variant in variantvector$Variant){
    verboseScatterplot(x = abs(geneModuleMembership[moduleGenes, column]),y = abs(GSTrait[moduleGenes, as.character(variant)]),
    xlab = paste("Module Membership in", modModule, "module"),
    ylab = paste("Gene significance for",as.character(variant)),
    main = paste("Module membership vs. gene significance\n"), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2)
  }
}

```
The hub genes of the tan module have high prognostic significance for trisomy12


#Module significance
```{r module significance}
 
##module significance? enrichment of significant genes in a module?
  #based on the mean correlation of module genes with trait
  modSig <- sum(abs(GSTrait[moduleGenes, variant]))/length(moduleGenes)
  verboseBarplot(modSig, variant,main="Module significance", col=levels(factor(mergedColors)))
  
  #based on the relative number of significant genes in the module (Significant: cor > 0.9)
  relModSig <- length(abs(GSTrait[moduleGenes, variant]) > 0.9)/length(moduleGenes)
  verboseBarplot(relModSig, variant,main="Module significance", col=levels(factor(mergedColors)))
  
  
```




Genetic variant:Trisomy12 
```{r trisomy12,  fig.height = 70, fig.width = 22}
#Write a function to list all genes contained in one module

#geneannotation
ensembl <- useMart("ensembl",dataset = "hsapiens_gene_ensembl")
anno <- getBM(values = rownames(RNAnorm),mart = ensembl, attributes = c("ensembl_gene_id","hgnc_symbol","description","chromosome_name","entrezgene"),filters = "ensembl_gene_id")
anno <- anno[!duplicated(anno$ensembl_gene_id),]
rownames(anno) <- anno[,1]


moduleNames <- unique(geneColor)

modulelist <-function(module){
  moduleGenes <- names(geneColor)[which(geneColor== module)]
  geneAnno <- anno[moduleGenes,]
  geneAnno <- geneAnno[!is.na(geneAnno$ensembl_gene_id),]
  return(geneAnno)
}

moduleGene <- sapply(moduleNames, modulelist, USE.NAMES = T) 

save(moduleGene, file = "/home/almut/Documents/CLL/data/geneModules_WGCNA25082017_ProteinCoding.RData")


#function to draw heatmap

modGene_exp <- function(colour){
  moduleTab <- as_data_frame(moduleGene[,colour])
  pheatmap(exprCLL.new[moduleTab$ensembl_gene_id,], treeheight_row = 0, scale = "row", 
         labels_row = moduleTab$hgnc_symbol,
         clustering_method = "ward.D2", main = paste0("gene expression in module", colour), annotation_col = colAnno)
}

#scale and censor
exprCLL.new <- log2(exprCLL)
exprCLL.new <- t(scale(exprCLL.new))
exprCLL.new[exprCLL.new > 4] <- 4
exprCLL.new[exprCLL.new < -4] <- -4

colAnno <- as.data.frame(colData(RNAnorm)[, c("PatID","batch","IGVH","trisomy12","RNAprep","del13q14", "del11q22.3", "c1c2", "SF3B1", "drugGroup")])
colAnno$PatID <- paste0(colAnno$PatID, "_", colAnno$c1c2)
rownames(colAnno) <- colAnno$PatID
colAnno <- colAnno[,-1]
#colAnno <- colAnno[colData(RNAnorm)$PatID,]
colAnno$RNAprep <- as.factor(colAnno$RNAprep)
colAnno <- colAnno[rownames(exprCLL),]



heatMap <- sapply("magenta", modGene_exp)
modGene_exp("cyan")


###trisomy12 and module black
#All genes that are associated to module tan
black <- as_data_frame(moduleGene[,"black"])


#Genes that are in tan, but not at chromosome 12. They are similar expressed to genes that are related to trisomy12
trisomy12Gene <- black %>% filter(chromosome_name != "12") 




```

